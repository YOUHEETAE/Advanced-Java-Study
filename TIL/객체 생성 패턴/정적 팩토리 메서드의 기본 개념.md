# 정적 팩토리 메서드의 기본 개념과 장단점

대다수 개발자는 **public 생성자**를 이용해 인스턴스를 만든다. 이는 객체를 생성하는 가장 기본적이고 직관적인 방법이다. 하지만 클래스는 생성자와 별도로 **정적 팩토리 메서드**를 제공할 수 있다. 정적 팩토리 메서드는 클래스 인스턴스를 반환하는 단순한 정적 메서드를 의미한다. 이 TIL에선 정적 팩토리 메서드의 기본 개념과 장단점에 대해 다룬다.

## 정적 팩토리 메서드란?

**정적 팩토리 메서드**는 클래스 인스턴스를 생성하여 반환하는 `public static` 메서드이다. 일반적인 생성자(`new` 키워드 사용)처럼 객체를 만들지만, 훨씬 **유연하고 강력한 장점**들을 제공한다. 클래스는 **생성자 대신** 또는 **생성자와 함께** 정적 팩토리 메서드를 제공할 수 있다.

주로 `from()`, `of()`, `getInstance()`, `create()`, `valueOf()`와 같이 의미 있는 이름을 가진다.

**간단한 예시:**

```java
class Product {
    private String name;
    private double price;

    // private 생성자: 외부에서 Product 객체를 'new'로 직접 만들지 못하게 막는다.
    private Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    // 정적 팩토리 메서드 1: 이름과 가격으로 제품 생성
    public static Product createProduct(String name, double price) {
        return new Product(name, price);
    }

    // 정적 팩토리 메서드 2: 특정 카테고리의 기본 제품 생성 (예시)
    public static Product createDefaultBook() {
        return new Product("기본 도서", 15000.0);
    }

    public String getName() { return name; }
    public double getPrice() { return price; }

    @Override
    public String toString() {
        return "Product{name='" + name + "', price=" + price + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        Product book1 = Product.createProduct("Java 프로그래밍", 35000.0);
        Product defaultBook = Product.createDefaultBook();

        System.out.println(book1);
        System.out.println(defaultBook);
    }
}
```

## 정적 팩토리 메서드의 장점

정적 팩토리 메서드는 단순한 public 생성자 보다 유리한 이유들을 제공한다.

### 1. 의미 있는 이름을 가질 수 있다.
생성자는 클래스와 같은 이름을 가져야 한다. 따라서 여러 생성자가 있을 경우 매개변수만으로 생성자를 구분해야 하는데 이는 클라이언트에게 **객체 생성의 의도나 맥락**을 모호하게 만들 수 있다.

하지만 정적 팩토리 메서드는 `createProduct()`, `createDefaultBook()`, `fromId()`처럼 **메서드 이름 자체로 객체 생성의 목적과 조건을 명확히 표현**할 수 있다. 이는 **코드의 가독성**을 크게 높여 개발자가 직관적으로 객체의 용도를 파악하고, 불필요한 실수를 줄이는 데 도움을 준다. 또한, 동일한 매개변수 타입을 가진 여러 생성자가 필요한 경우에도 이름을 통해 **명확하게 구분**할 수 있다는 장점이 있다.

### 2. 호출될 때마다 새로운 객체를 만들 필요가 없다.
`public` 생성자는 호출될 때마다 ***새로운 인스턴스를 생성***한다. 이는 같은 상태의 객체가 필요하거나 객체 생성이 비싼 작업일 경우 ***비효율적**일 수 있다.

하지만 정적 팩토리 메서드는 호출될 때마다 ***새로운 객체를 만들 필요***가 없다. 이미 생성된 객체를 ***캐싱하여 재활용*** 하거나, 특정 조건에 따라 ***동일한 인스턴스를 반환***할 수 있다. 이에 따라 정적 팩토리 메서드는 ***객체 생성의 비용***을 줄이고 ***자원 사용을 효율적으로 관리***할 수 있는 강력한 메커니즘을 제공한다.

### 3. 반환할 타입의 하위 객체를 유연하게 변경할 수 있다.

`puplic` 생성자는 ***구체적인 구현체에 강하게 의존***하는 특징이 있다. 이는 구현체의 코드를 수정할때, 해당 구현체를 사용하는 모든 클라이언트 코드를 수정해야하는 불편함을 발생시킨다.

정적 팩토리 메서드의 경우 클라리언트가 ***구체적인 타입***을 알 필요가 없다. 예시를 보며 이해해보자.

**간단한 예시**

```java
public class AnimalFactory {
    // 반환 타입은 Animal (인터페이스/추상 클래스)
    public static Animal createAnimal(String type) {
        if ("사자".equalsIgnoreCase(type)) {
            return new Lion(); // 실제로는 Lion 객체 반환
        } else if ("호랑이".equalsIgnoreCase(type)) {
            return new Tiger(); // 실제로는 Tiger 객체 반환
        } else {
            return null;
        }
    }
}
```
클라이언트는 `AnimalFactory.createAnimal("사자")`를 호출하면 객체의 타입이 `Animal`이라는 것만 알면된다. 이 객체가 `Lion`인지 `Tiger`인지 구체적인 타입을 알 필요가 없다.

만약 나중에 "사자"라는 요청이 들어왔을때 `AfricanLion`을 반환받고 싶다면 정적 팩토리 메서드의 내부 코드만 수정하면 된다. 이때 `AnimalFactory.createAnimal()`를 호출하는 클라이언트 코드는 수정할 필요가 전혀 없다. 이러한 특성은 정적 팩토리 메서드에 ***유지보수성과 확장성***을 크게 증가 시킨다.

### 4. 입력 매개변수에 따라 매번 다른 객체를 반환할 수 있다.

위의 예시 코드를 보면 `AnimalFactory.createAnimal("사자")`를 호출하면 `Lion` 객체가, `AnimalFactory.createAnimal("호랑이")`를 호출하면 `Tiger`객체가 생성된다. 이처럼 클라이언트는 ***매개변수를 입력하여 원하는 객체를 반환***할 수 있다. 또한, ***특정 조건***에 따라 ***적절한 구현체를 선택적으로 호출***할 수 있다. 

이러한 특성은 정적 팩토리 메서드의 ***유연성과 확장성, 그리고 낮은 결합도***를 보장하는데 매우 효과적이다.

## 정적 팩토리 메서드의 단점 

지금까지 보면 정적 팩토리 메서드는 `public`생성자보다 훨씬 많은 장점을 가지고 있는것 같다. 하지만 물론 단점도 존재한다.

### 1. 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.

상속을 하려면 `public`이나 `protected`생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다. 하지만 이 제약은 ***상속보다 컴포지션을 이용하도록 유도***하기 때문에 오히려 장점으로 볼수도 있다.

### 2. 프로그래머가 찾기 어렵다.

정적 팩토리 메서드는 `public`생성자와 달리 `new`키워드를 사용하지 않기 때문에 ***인스턴스화할 방법***을 직접 찾아야한다.

이 때문에 정적 팩토리 메서드를 사용하는 클래스는 메서드 이름을 통해 ***객체 생성의 의도를 명확하게 전달***하는 것이 매우 중요하다.

