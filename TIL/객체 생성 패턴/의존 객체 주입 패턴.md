# 의존 객체 주입 패턴

클래스가 여러 객체을 필요로 하고, 그때마다 사용자가 원하는 객체을 유연하게 제공해야 할때 **정적 유틸리티 클래스나 싱글턴 패턴은 적합하지 않다**.

그렇다고 클래스 내부에서 `new` 키워드를 통해 직접 객체를 생성하면, 특정 구현체에 강하게 의존하는 **'높은 결합도'** 문제가 발생한다. 이는 코드의 유연성과 테스트 용이성을 크게 떨어뜨린다. 이러한 문제를 해결해주는 설계 패턴이 바로 **의존성 주입(DI)**이다. 이제부터 이 패턴에 대해 알아보자.

##  📝 의존성 주입이란?
의존성 주입이란 객체 스스로가 의존하는 다른 객체를 직접 생성하는 대신, 외부에서 의존 객체를 주입받는 설계 패턴이다. 이는 **제어의 역전(IoC)**이라는 더 큰 개념의 한 종류로, 객체 생성의 제어권을 외부로 넘기는 것을 의미한다.

한 클래스가 다른 클래스의 기능을 사용해야 할 때, new 키워드로 직접 객체를 만드는 것이 아니라 이미 만들어져 있는 객체를 가져다 쓰는 방식이다.

## 🤔 언제 사용하는가?

### 적절한 경우

- 외부 API 호출하는 서비스

- 데이터베이스 액세스 계층

- 비즈니스 로직 서비스

- 설정이 자주 바뀌는 컴포넌트

### 피해야 할 경우

- 간단한 유틸리티 클래스

- 값 객체 (Value Object)

- 상태가 없는 정적 메서드만 있는 클래스


## 💻 구현 방법

### Before DI 
```java
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        // 강한 결합, 직접 생성
        this.userRepository = new MySQLUserRepository();
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}
```

### After DI
```java
public class UserService {
    private final UserRepository userRepository;
    
    // 생성자 주입
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}
```

## 🔧 DI 구현 방식

### 1. 생성자 주입 (Constructor Injection)

가장 권장되는 방식으로, 객체 생성 시점에 의존성을 주입한다.

```JAVA
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}
```

**장점:**

- 불변성 보장 (final 키워드 사용 가능)
  
- 필수 의존성을 명확히 표현
  
- 테스트하기 쉬움

### 2. 세터 주입 (Setter Injection)
   
setter 메서드를 통해 의존성을 주입한다.

```JAVA
public class UserService {
    private UserRepository userRepository;
    
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**장점:**

- 선택적 의존성에 적합
  
- 런타임에 의존성 변경 가능

**단점:**

- 객체가 불완전한 상태로 존재할 수 있음

### 3. 필드 주입 (Field Injection)
   
어노테이션을 사용해 필드에 직접 주입한다.

```JAVA
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

**단점:**

- 테스트하기 어려움
  
- 불변성 보장 불가
  
- 숨겨진 의존성으로 인한 복잡도 증가
  
## ✅ 의존성 주입의 장점

- **1. 낮은 결합도**
  - 구체적인 클래스가 아닌 인터페이스에 의존하기 때문에, 어떠한 객체를 주입하든 유연하게 대처 가능하다.

- **2. 쉬운 테스트**
  - DI를 사용하면 테스트 시에 실제 객체 대신 **가짜 객체**를 주입할 수 있다. 덕분에 의존성이 있는 외부 환경에 구애받지 않고 해당 클래스의 기능만 독립적으로 테스트하기 쉬워진다.

- **3. 높은 재사용성**
  - 객체를 재사용하기가 용이해지고, 변경이 필요할 때 해당 객체만 교체하면 되므로 유지보수 비용을 줄일 수 있다.

## ❌ 단점

- **1. 복잡성 증가**
  - 초기 설정과 학습 비용이 요구된다.

- **2. 런타임 오류** 
  - 컴파일 타임에 의존성 오류 발견이 어렵다.

- **3. 디버깅 어려움**
  - 객체 생성 과정이 숨겨지기 때문에 디버깅에 어려움이 있을 수 있다.

## 마무리하며

의존성 주입 방식은 현재 소프트웨어 개발에서 매우 중요한 객체 생성 및 관리 방식이다. 특히 스프링과 같은 주요 프레임워크에서 핵심 개념으로 사용되면서, 현대 개발에서 필수적인 패턴으로 자리 잡았다.

의존성 주입 방식에 대한 이해를 바탕으로 더 유연하고 확장 가능한 코드를 작성하여 생산성을 높여보자.



