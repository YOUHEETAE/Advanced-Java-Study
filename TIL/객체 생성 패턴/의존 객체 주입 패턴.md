# 의존 객체 주입 패턴

클래스가 여러 객체을 필요로 하고, 그때마다 사용자가 원하는 객체을 유연하게 제공해야 할때 **정적 유틸리티 클래스나 싱글턴 패턴은 적합하지 않다**.

그렇다고 클래스 내부에서 `new` 키워드를 통해 직접 객체를 생성하면, 특정 구현체에 강하게 의존하는 **'높은 결합도'** 문제가 발생한다. 이는 코드의 유연성과 테스트 용이성을 크게 떨어뜨린다. 

이러한 문제를 해결해주는 설계 패턴이 바로 **의존성 주입(DI)**이다. 이제부터 이 패턴에 대해 알아보자.

##  📝 의존성 주입이란?
의존성 주입이란 객체 스스로가 의존하는 다른 객체를 직접 생성하는 대신, **외부에서 의존 객체를 주입**받는 설계 패턴이다.

한 클래스가 다른 클래스의 기능을 사용해야 할 때, `new` 키워드로 직접 객체를 만드는 것이 아니라 이미 만들어져 있는 객체를 가져다 쓰는 방식이다.

## 🤔 언제 사용하는가?

### 적절한 경우

- 외부 API 호출하는 서비스

- 데이터베이스 액세스 계층

- 비즈니스 로직 서비스

- 설정이 자주 바뀌는 컴포넌트

### 피해야 할 경우

- 간단한 유틸리티 클래스

- 값 객체 (Value Object)

- 상태가 없는 정적 메서드만 있는 클래스


## 💻 구현 방법

### Before DI 
```java
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        // 강한 결합! 직접 생성
        this.userRepository = new MySQLUserRepository();
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}
```

### After DI (개선된 코드)
```java
public class UserService {
    private final UserRepository userRepository;
    
    // 생성자 주입
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}
```

## 🔧 DI 구현 방식

의존성 주입 방식은 많지만 그 중에선 생성자 주입 방식이 가장 권장된다.

```java
public class OrderService {
    // final 키워드로 불변성 보장
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    
    /**
     * 생성자를 통해 의존성 주입
     * - 객체 생성 시점에 모든 의존성이 주입됨
     * - final 필드와 함께 사용하여 불변 객체 생성
     */
    public OrderService(PaymentService paymentService, 
                       NotificationService notificationService) {
        this.paymentService = paymentService;
        this.notificationService = notificationService;
    }
    
    // 비즈니스 로직에서 주입된 의존성 사용
    public void processOrder(Order order) {
        paymentService.processPayment(order.getPayment());
        notificationService.sendConfirmation(order.getCustomer());
    }
}
```
## ✅ 장점

- **1. 낮은 결합도**
  - 구체적인 클래스가 아닌 인터페이스에 의존하기 때문에, 어떠한 객체를 주입하든 유연하게 대처 가능하다.

- **2. 쉬운 테스트**
  - DI를 사용하면 테스트 시에 실제 객체 대신 **가짜 객체**를 주입할 수 있다. 덕분에 의존성이 있는 외부 환경에 구애받지 않고 해당 클래스의 기능만 독립적으로 테스트하기 쉬워진다.

- **3. 높은 재사용성**
  - 객체를 재사용하기가 용이해지고, 변경이 필요할 때 해당 객체만 교체하면 되므로 유지보수 비용을 줄일 수 있다.

## ❌ 단점

- **1. 복잡성 증가**
  - 초기 설정과 학습 비용이 요구된다.

- **2. 런타임 오류** 
  - 컴파일 타임에 의존성 오류 발견이 어렵다.

- **3. 디버깅 어려움**
  - 객체 생성 과정이 숨겨지기 때문에 디버깅에 어려움이 있을 수 있다.





