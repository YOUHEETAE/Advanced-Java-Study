# 객체의 재사용
똑같은 기능을 수행하는 객체가 여러 번 필요할 때, 인스턴스를 매번 생성하는 것은 비효율적이다. 이 경우, 한번 생성한 객체를 재사용하면 어플리케이션의 성능과 효율을 크게 높일 수 있다. 객체를 재사용하는 방법에 대해 알아보고 그 장점에 대해 알아보자.

## 🔍 왜 객체를 재사용해야 할까?

### 성능 향상

- ***메모리 절약 :*** 새로운 객체 생성에 따른 메모리 할당 비용 절감

- ***GC 압력 감소 :*** 가비지 컬렉션 발생 빈도 및 시간 단축

- ***CPU 사용량 감소 :*** 객체 생성/초기화 오버헤드 제거

### 리소스 효율성

- 시스템 자원의 효율적 활용

- 특히 무거운 객체(DB 연결, 네트워크 소켓 등)에서 효과적

## 🛠️ 주요 재사용 패턴

### 1. 객체 풀 패턴

`Queue`나 `Stack` 같은 자료구조를 이용하여 객체를 관리하고 재사용한다.

```JAVA
public class StringBuilderPool {
    private final Queue<StringBuilder> pool = new ConcurrentLinkedQueue<>();
    
    public StringBuilder borrowObject() {
        StringBuilder sb = pool.poll();
        return sb != null ? sb.setLength(0) : new StringBuilder();
    }
    
    public void returnObject(StringBuilder sb) {
        if (sb.capacity() < 1024) {  // 크기 제한
            pool.offer(sb);
        }
    }
}
```

### 2. 플라이웨이트 패턴

수많은 객체들이 대부분 동일한 속성을 가질 때, 객체의 상태를 **변하지 않는 고유 상태**와 **자주 변하는 개별 상태** 로 분리하여 관리한다. 고유 상태를 가진 객체는 하나만 만들어 재사용하며, 개별 상태는 필요에 따라 따로 관리하여 메모리 사용량을 크게 줄인다.

```JAVA
public class FontFactory {
    private static final Map<String, Font> fonts = new HashMap<>();
    
    public static Font getFont(String name) {
        return fonts.computeIfAbsent(name, Font::new);
    }
}
```

### 3. 캐싱 패턴

 캐싱은 객체 재사용의 가장 포괄적인 전략이다. 자주 사용되는 데이터나 객체를 임시 저장소(캐시)에 보관해 두었다가, 새로 생성하거나 가져오는 대신 캐시에서 바로 사용하는 방식이다. 

```JAVA
// 기본 캐싱 구현
public class ComputationCache {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public Object getResult(String key, Supplier<Object> computation) {
        return cache.computeIfAbsent(key, k -> computation.get());
    }
}

// LRU 캐시 구현 (용량 제한)
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);  // accessOrder = true
        this.capacity = capacity;
    }
    
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;  // 용량 초과 시 가장 오래된 항목 제거
    }
}

// 사용 예제
LRUCache<String, String> lruCache = new LRUCache<>(100);
lruCache.put("key1", "value1");  // 캐시에 저장
String result = lruCache.get("key1");  // 캐시에서 조회
```

## ⚠️ 주의사항

### 상태관리

```JAVA
public class ReusableObject {
    private String data;
    
    public void reset() {
        this.data = null;  // 재사용 전 상태 초기화 필수
    }
}
```

### 메모리 누수

```JAVA
public class ObjectPool<T> {
    private final Queue<T> pool = new ConcurrentLinkedQueue<>();
    
    public void returnObject(T obj) {
        // 무제한 객체 보관 시 메모리 누수 위험
        if (pool.size() < MAX_SIZE) {  // 크기 제한 필요
            pool.offer(obj);
        }
    }
}
```

### 동시성 문제

```JAVA
// Thread-safe하지 않은 객체 재사용 시 주의
public class UnsafeCounter {
    private int count = 0;
    
    public void increment() {
        count++;  // 동시성 문제 발생 가능
    }
}
```

## 📊 언제 사용하면 좋을까?

### 적합한 경우

- 객체 생성 비용이 높은 경우

- 동일한 객체를 자주 생성/소멸하는 경우

- 메모리 사용량이 중요한 환경

- 성능이 critical한 시스템

### 부적합한 경우

- 객체 생성 비용이 낮은 경우

- 객체 사용 빈도가 낮은 경우

- 상태 관리가 복잡한 객체

- 동시성 제어가 어려운 환경

## 💡 마무리하며

객체의 재사용은 성능 최적화를 위한 강력한 도구이지만, 잘못 사용하면 복잡성을 높이고 버그를 유발할 수 있다. 단순한 객체라면 새로 생성하는 것이 더 안전하고 코드 가독성을 높일 수 있다. 

적절한 사용 시점을 파악하고 명확한 성능상의 이점이 있을 때만 이용하는 습관을 가져보자.









