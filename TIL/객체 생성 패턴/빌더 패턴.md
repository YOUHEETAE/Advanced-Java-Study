# 빌더 패턴

정적 팩터리와 생성자는 선택 매개변수가 많을 때 대응하기 어렵다는 특징이 있다. 이러한 경우 점층적 생성자 패턴, 자바빈즈 패턴, 빌더 패턴등을 고려할 수 있다. 이 세가지 객체 생성 방식은 각각의 장단점들이 있지만 현대 소프트웨어 개발에서 가장 선호되는 방식은 빌더 패턴이다. 빌더 패턴의 기본 개념과 실제 프로젝트에서의 활용 예시를 알아보자.

## 빌더 패턴이란?

빌더 패턴이란 빌더라는 중간 개입 객체를 이용하여 복잡한 객체 생성 방식을 유연하고 가독성 있게 처리하는 디자인 패턴이다. 

**왜 빌더 패턴이 필요할까?** 미적용 예시를 보며 이해해보자.

```JAVA
public class Coffee {
    // 필수 매개변수
    private String type; // 커피 종류 (예: Americano, Latte)
    private String size; // 사이즈 (예: Tall, Grande, Venti)

    // 선택적 매개변수 (기본값 설정 가능)
    private boolean hasWhipCream; // 휘핑크림 추가 여부
    private String syrup;         // 시럽 종류 (예: Vanilla, Caramel)

    // 모든 매개변수를 받는 생성자
    public Coffee(String type, String size, boolean hasWhipCream, String syrup) {
        this.type = type;
        this.size = size;
        this.hasWhipCream = hasWhipCream;
        this.syrup = syrup;
    }

    @Override
    public String toString() {
        return "Coffee{" +
               "type='" + type + '\'' +
               ", size='" + size + '\'' +
               ", hasWhipCream=" + hasWhipCream +
               ", syrup='" + syrup + '\'' +
               '}';
    }
}
```
`Coffee`라는 클래스가 있다. 커피의 `타입`과 `사이즈`는 필수 사항이지만 `휘핑크림 추가 여부`나 `시럽의 종류`는 선택 사항이라고 가정한다. 

```JAVA
public class CoffeeOrder {
    public static void main(String[] args) {
        // 1. 일반적인 아메리카노 주문 (휘핑크림X, 시럽X)
        // 선택적 매개변수를 기본값(false, null)으로 채워줘야 함
        Coffee americano = new Coffee("Americano", "Grande", false, null);
        System.out.println("주문 1: " + americano);
    }
}
```
이 예시에서 발생하는 문제점을 파악해보자.

- **매개변수의 의미 파악 어려움 :** `Coffee americano = new Coffee("Americano", "Grande", false, null);` 이 코드에서 `false`와 `null`이 무엇을 의미하는지 알기 위해선 클래스의 코드를 직접 봐야한다.

- **순서 강제 :** 매개변수 순서가 정해져 있어, 원하지 않는 선택적 매개변수(예: `휘핑크림`)가 있어도 그 자리에 `false`나 `null` 같은 값을 반드시 채워 넣어야 한다.

- **유연성 부족:** 내가 원하는 특정 선택적 매개변수만 골라서 설정하기 어렵다.

**이제 빌더 패턴을 사용해보자.**

```JAVA
public class Coffee {
    // 필수 매개변수 (final로 불변성 보장)
    private final String type;
    private final String size;

    // 선택적 매개변수 (final로 불변성 보장, 빌더에서 기본값 설정)
    private final boolean hasWhipCream;
    private final String syrup;

    // private 생성자: 빌더 객체를 통해서만 생성되도록 강제
    private Coffee(Builder builder) {
        this.type = builder.type;
        this.size = builder.size;
        this.hasWhipCream = builder.hasWhipCream;
        this.syrup = builder.syrup;
    }

    // Getter 메서드
    public String getType() { return type; }
    public String getSize() { return size; }
    public boolean hasWhipCream() { return hasWhipCream; }
    public String getSyrup() { return syrup; }

    @Override
    public String toString() {
        return "Coffee{" +
               "type='" + type + '\'' +
               ", size='" + size + '\'' +
               ", hasWhipCream=" + hasWhipCream +
               ", syrup='" + syrup + '\'' +
               '}';
    }

    // --- 2. Coffee 객체를 만들기 위한 Builder 클래스 ---
    public static class Builder {
        // 빌더의 필드: Coffee 객체 필드와 동일 (여기서는 final을 사용하지 않음)
        // 필수 매개변수
        private final String type;
        private final String size;

        // 선택적 매개변수 (빌더에서 기본값 설정 가능)
        private boolean hasWhipCream = false; // 기본값: 휘핑크림 없음
        private String syrup = null;         // 기본값: 시럽 없음

        // 빌더의 생성자: 필수 매개변수
        public Builder(String type, String size) {
            this.type = type;
            this.size = size;
        }

        // 3. 선택적 매개변수를 설정하는 메서드 (메서드 체이닝을 위해 this 반환)
        public Builder hasWhipCream(boolean hasWhipCream) {
            this.hasWhipCream = hasWhipCream;
            return this;
        }

        public Builder syrup(String syrup) {
            this.syrup = syrup;
            return this;
        }

        // 4. 최종적으로 Coffee 객체를 생성하는 build() 메서드
        public Coffee build() {
            // 필요하다면 여기서 유효성 검사 로직을 추가할 수 있음
            return new Coffee(this); // Coffee의 private 생성자 호출
        }
    }
}
```
### 1단계: Coffee 클래스 (최종 객체)
**Coffee**는 우리가 최종적으로 사용할 객체다.

- **불변성**: `type`, `size` 같은 모든 필드는 `final`로 선언한다. 즉, 한 번 만들어지면 절대 변하지 않는 객체다.
- **숨겨진 생성자**: `private` 생성자를 사용하여 외부에서 직접 Coffee 객체를 만들지 못하게 막는다. 오직 **빌더만** 이 생성자를 사용할 수 있다.
- **Getter만 제공**: 객체 상태를 변경하는 Setter는 제공하지 않는다. Getter로 값만 읽을 수 있다.

### 2단계: Builder 클래스 (객체 생성 도우미)
**Builder**는 Coffee 객체를 만들어주는 **'중간 개입 객체'**다. Coffee 클래스 내부에 `static`으로 정의한다.

- **필드**: Coffee와 같은 필드를 가지지만, 객체 생성 과정 중 값을 계속 설정해야 하므로 `final`은 사용하지 않는다.
- **필수 매개변수 받기**: 빌더를 만들 때 필수 매개변수만 받는다.  
  예: `new Coffee.Builder("아메리카노", "Grande")`
- **선택적 설정 메서드**:
  - `.hasWhipCream(true)`
  - `.syrup("바닐라")`  
  처럼 원하는 선택 옵션만 설정하는 메서드를 제공한다.  
  각 메서드는 빌더 자신(`this`)을 반환하여 **메서드 체이닝**을 가능하게 한다.
- **build() 메서드**: 모든 설정이 끝나면 `build()`를 호출한다.  
  빌더가 모은 정보를 이용해 최종 Coffee 객체를 생성하고 반환한다.

### 3단계: 빌더 패턴 활용 (객체 생성)
`Coffee.Builder`를 사용하면 Coffee 객체를 매우 직관적이고 유연하게 생성할 수 있다.

- **간단한 생성:** `new Coffee.Builder("아메리카노", "Grande").build();` 

  - 필수 값만 주면 나머지 선택 옵션들은 빌더의 기본값이 적용된다.

- **선택적 옵션만 설정:** `new Coffee.Builder("라떼", "Tall").syrup("바닐라").build();`

  - 필요한 옵션만 명확하게 지정하고, 원치 않는 옵션은 무시할 수 있다.

- **자유로운 조합:** `new Coffee.Builder("모카", "Venti").hasWhipCream(true).build();`

  - 매개변수 순서에 얽매이지 않고 여러 옵션을 자유롭게 조합하여 객체를 생성한다.

## 프로젝트 응용
빌더 패턴은 실제 프로젝트에서도 많이 쓰이는 패턴 중 하나다. 특히 엔티티 객체를 디티오 객체로 변환할 때 많이 쓰인다. 다음 코드는 대학 프로젝트에서 빌터 패턴을 이용한 예시이다.

```JAVA
public class HospitalConverter {
    
    
    //Hospital 엔티티를 HospitalResponseDto로 변환
    public HospitalWebResponse convertToDTO(HospitalMain hospitalMain) {
        if (hospitalMain == null) {
            return null;
        }
        
        HospitalDetail detail = hospitalMain.getHospitalDetail();
        
        TodayOperatingTimeCalculator.TodayOperatingTime todayTime = 
                TodayOperatingTimeCalculator.getTodayOperatingTime(detail);
            
       
        
        return HospitalWebResponse.builder()
            // 기본 정보
            .hospitalName(hospitalMain.getHospitalName())
            .hospitalAddress(hospitalMain.getHospitalAddress())
            .provinceName(hospitalMain.getProvinceName())
            .districtName(hospitalMain.getDistrictName())
            .hospitalTel(hospitalMain.getHospitalTel())
            .hospitalHomepage(hospitalMain.getHospitalHomepage())
            .doctorNum(hospitalMain.getDoctorNum())
            
            // 좌표 정보
            .coordinateX(hospitalMain.getCoordinateX())
            .coordinateY(hospitalMain.getCoordinateY())
            
            // 운영 정보 (detail이 있을 때만)
            .emergencyDayAvailable(detail != null ? detail.getEmyDayYn() : null)
            .emergencyNightAvailable(detail != null ? detail.getEmyNightYn() : null)
            .weekdayLunch(detail != null ? detail.getLunchWeek() : null)
            .parkingCapacity(detail != null ? detail.getParkQty() : null)
            .parkingFee(detail != null ? detail.getParkXpnsYn() : null)
            
            //운영 시간
            .todayOpen(formatTime(todayTime.getOpenTime()))
            .todayClose(formatTime(todayTime.getCloseTime()))
            
            .medicalSubject(convertMedicalSubjectsToString(hospitalMain.getMedicalSubjects()))
            
         
            // 전문의 정보를 문자열로 변환
            .professionalDoctors(convertProDocsToString(hospitalMain.getProDocs()))
            .build();
    }
```

## 마무리하며


오늘은 빌더 패턴의 핵심 개념부터 실제 코드 예시, 그리고 실무에서 어떻게 활용되는지까지 정리해 보았다.

**빌더 패턴의 핵심 요약**
- 개념: 복잡한 객체를 만들 때, `Builder`라는 중간 객체를 이용해 단계적으로, 유연하게 생성하는 디자인 패턴이다.

- 필요성: 매개변수가 많거나 선택적 매개변수가 많은 객체를 만들 때, 코드의 가독성과 유연성이 떨어지는 문제를 해결한다.

- 작동 방식:

  - 1단계: 최종 객체는 `private` 생성자를 사용하여 외부에서 직접 만들 수 없게 한다.

  - 2단계: `Builder`라는 `static` 중첩 클래스를 만들고, 이 빌더를 통해 필요한 매개변수들을 설정한다.

  - 3단계: `build()` 메서드를 호출하면, 빌더가 모아둔 정보로 완전하게 초기화된 불변(Immutable) 객체를 반환한다.

- 주요 장점:

  - 가독성: `builder.메서드().메서드()`처럼 메서드 체이닝을 통해 어떤 필드를 설정하는지 명확하게 알 수 있다.

  - 유연성: 필수 매개변수만으로 객체를 만들 수 있고, 원하는 선택적 매개변수만 골라서 설정할 수 있다.

  - 안전성: `setter`가 없으므로 객체가 불변 상태를 유지해 스레드 안전성을 높인다.

**실무 활용**

빌더 패턴은 특히 엔티티(Entity)를 DTO(Data Transfer Object)로 변환할 때 유용하다. Entity의 복잡한 데이터를 클라이언트에게 필요한 형태로 가공하여 전달할 때, 빌더 패턴을 사용하면 코드의 유연성과 안정성을 동시에 확보할 수 있다. Lombok의 `@Builder` 어노테이션을 사용하면 이 과정을 더욱 간결하게 자동화할 수 있다.

복잡한 객체 생성이 필요한 상황이라면, 빌더 패턴을 적용하여 더 깔끔하고 안전한 코드를 작성해 보자.












